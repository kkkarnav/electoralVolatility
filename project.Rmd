---
title: "Where Does The Buck Stop? Economic Conditions & Electoral Volatility"
author: "Karnav Popat & Shashwat Agarwal"
date: "21/03/2024"
output: 
  prettydoc::html_pretty:
    theme: architect
    highlight: vignette
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE, warning = FALSE, message = FALSE)
library(tidyverse)
library(dplyr)
library(lubridate)
library(kableExtra)
library(sf)
```

```{r data, include=FALSE}
general <- read.csv("D:/ashoka/sem6/d3s/TCPD/TCPD_GE_All_States_2023-2-2.csv")
assembly <- read.csv("D:/ashoka/sem6/d3s/TCPD/All_States_AE.csv")

assembly_shp <- st_read("D:/ashoka/sem6/d3s/shp/assembly_constituencies.shp")
```

## Research Question

We know that voters punish incumbents when the economy goes sour. At what level of governance do voters allocate responsibility for economic underperformance? Any voter in India is under atleast three levels of governance: local represenntation, state government, and central government. In the United States, where popular perception of control is focused on the President, voters tend to punish the President's party. Does this hold true for India, where economic initiative is (or was) significantly more decentralized?

## Dependent Variable

To measure how voters reward and punish retrospective economic conditions, we use electoral volatility. We can calculate this for each constituency and each election using TCPD's election datasets.

```{r tcpd, include=FALSE}
kable(head(general), caption="General Elections Dataset")
kable(head(assembly), caption="Assembly Elections Dataset")
```

Some of the indicators used in Dash & Ferris are calculated at the constituency level, rather than being specific to candidate or party. These are the voter turnout (which indicates the level of democratic participation) and Effective Number of Parties (ENOP, which indicates the effective degree of choice that the voter has).

```{r vote_stats}
aggregate_electoral_indicators <- assembly %>%
  group_by(State_Name, Year, Constituency_Name)%>%
  summarize(total_votes=sum(Votes), Electors=first(Electors), Turnout_Percentage=first(Turnout_Percentage), ENOP=first(ENOP))
```

```{r vote_stats table, echo=FALSE}
kable(head(aggregate_electoral_indicators), caption="Aggregate Electoral Indicators") %>%
  kable_styling(font_size=12)
```

More comprehensive measures of voting behaviour are calculated from one election to another. Electoral Volatility is expressed as:
$$
\frac{\sum_{p=1}^{n}V_{pt} - V_{p(t-1)}}{2}
$$
for each party _p_ between election _t_ and _t-1_. To calculate this, we first widen the dataset to get each party's voteshare in each election.

``` {r partywise}
assembly <- assembly%>%
  mutate(Year = as.integer(Year))%>%
  filter(Year >= 2014)

# Aggregate the dataframe by party instead of by candidate
partywise_votes <- assembly %>%
  filter(last_poll == TRUE)%>%
  group_by(State_Name, Constituency_Name, Constituency_No, Year, Assembly_No, Party)%>%
  summarize(Votes=sum(Votes), Valid_Votes=sum(Valid_Votes), Electors=first(Electors), Constituency_Type=first(Constituency_Type), Vote_Share_Percentage=sum(Vote_Share_Percentage))%>%
  ungroup()
```

``` {r pivot}
# Extract the list of parties
party_list <- as.list(unique(partywise_votes$Party))

# Widen the dataframe for each party
for (party in party_list) {
  partywise_votes[[paste0("Party_", party)]] <- ifelse(partywise_votes$Party == party, partywise_votes$Vote_Share_Percentage, 0)
}
partywise_votes <- partywise_votes%>%
  select(-Party, -Votes, -Valid_Votes, -Electors, -Constituency_Type)%>%
  group_by(State_Name, Constituency_Name, Constituency_No, Assembly_No, Year)%>%
  summarise_all(.funs = function(x) sum(x))%>%
  ungroup()
```

```{r partywise_votes table, echo=FALSE}
kable(head(partywise_votes, 10), caption="Party-wise Vote Shares in Assembly Elections")%>%
  kable_styling(font_size=12)
```

We can now calculate electoral volatility using the Pedersen formula:

``` {r volatility}
# Calculate the volatility by summing the deltas for each party
partywise_deltas <- partywise_votes%>%
  group_by(State_Name, Constituency_Name, Constituency_No)%>%
  mutate_at(vars(starts_with("Party_")), 
            funs(abs(. - lag(.))))%>%
  mutate_all(~replace(., is.na(.), 0))%>%
  mutate_at(vars(matches("^Party")), as.numeric)%>%
  ungroup()%>%
  mutate(volatility=rowSums(select(., starts_with("Party_")))/2)

volatility <- partywise_deltas%>%
  filter(volatility != 0)%>%
  select(State_Name, Constituency_Name, Constituency_No, Year, Assembly_No, volatility)
```

``` {r volatility table, echo=FALSE}
kable(head(volatility, 10), caption="Volatility in Assembly Elections")%>%
  kable_styling(font_size=12)
```

This gives us our dependent variable, electoral volatility, at the district level.

``` {r boxplot_state, echo=FALSE}
ggplot(volatility, aes(x = factor(State_Name), y = volatility)) +
  geom_boxplot() +
  labs(title = "Volatility by State") +
  xlab("State/UT") +
  ylab("% Volatiliy") +
  theme(axis.text.x = element_text(angle = 45))
```

``` {r boxplot_year, echo=FALSE}
ggplot(volatility, aes(x = factor(Year), y = volatility)) +
  geom_boxplot() +
  labs(title = "Volatility by Election") +
  xlab("Year") +
  ylab("% Volatiliy") +
  theme(axis.text.x = element_text(angle = 45))
```

To test our hypothesis, we'd want to narrow this down by calculating electoral volatility separately for the local incumbent party, the ruling state party, and the ruling central party.

``` {shapefile}
assembly_shp <- assembly_shp%>%
  filter(state == "Andhra Pradesh")

volatility <- volatility%>%
  filter(State_Name == "Andhra_Pradesh")

assembly_shp <- assembly_shp[, c("state", "ac", "ac_name", "geometry")]
assembly_shp = as.data.frame(sapply(assembly_shp, toupper))

assembly_shp <- inner_join(assembly_shp, volatility, by=c("ac_name" = "Constituency_Name"))
```

## Independent Variable

To measure natiowide economic conditions over time, we use night-lights data as a proxy. This is a well-established though inherently limited practiced. We can get night-lights data from SHRUG.

```{r shrug, include=FALSE}
kable(head(general), caption="General Elections Dataset")
kable(head(assembly), caption="Assembly Elections Dataset")
```

``` {r parties_by_election}
parties <- assembly %>%
  group_by(State_Name, Constituency_Name, Year) %>%
  summarize(Parties=list(unique(Party)))%>%
  arrange(State_Name, Constituency_Name, Year)%>%
  mutate(
    Prev_Parties=ifelse(
      lag(State_Name) == State_Name & lag(Constituency_Name) == Constituency_Name,
      lag(Parties),
      NA
    )
  )%>%
  rowwise()%>%
  mutate(Continuing_Parties = list(intersect(Prev_Parties, Parties)))
```

```{r parties_by_election table, echo=FALSE}
kable(head(parties), caption="Parties contesting each Assembly Election")%>%
  kable_styling(font_size=12)
```

## Including Plots

You can also embed plots, for example:

```{r pressure, echo=FALSE}
plot(pressure)
```

Note that the `echo = FALSE` parameter was added to the code chunk to prevent printing of the R code that generated the plot.
